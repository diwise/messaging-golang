// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package messaging

import (
	"sync"
)

// Ensure, that IncomingTopicMessageMock does implement IncomingTopicMessage.
// If this is not the case, regenerate this file with moq.
var _ IncomingTopicMessage = &IncomingTopicMessageMock{}

// IncomingTopicMessageMock is a mock implementation of IncomingTopicMessage.
//
//	func TestSomethingThatUsesIncomingTopicMessage(t *testing.T) {
//
//		// make and configure a mocked IncomingTopicMessage
//		mockedIncomingTopicMessage := &IncomingTopicMessageMock{
//			BodyFunc: func() []byte {
//				panic("mock out the Body method")
//			},
//			ContentTypeFunc: func() string {
//				panic("mock out the ContentType method")
//			},
//			TopicNameFunc: func() string {
//				panic("mock out the TopicName method")
//			},
//		}
//
//		// use mockedIncomingTopicMessage in code that requires IncomingTopicMessage
//		// and then make assertions.
//
//	}
type IncomingTopicMessageMock struct {
	// BodyFunc mocks the Body method.
	BodyFunc func() []byte

	// ContentTypeFunc mocks the ContentType method.
	ContentTypeFunc func() string

	// TopicNameFunc mocks the TopicName method.
	TopicNameFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Body holds details about calls to the Body method.
		Body []struct {
		}
		// ContentType holds details about calls to the ContentType method.
		ContentType []struct {
		}
		// TopicName holds details about calls to the TopicName method.
		TopicName []struct {
		}
	}
	lockBody        sync.RWMutex
	lockContentType sync.RWMutex
	lockTopicName   sync.RWMutex
}

// Body calls BodyFunc.
func (mock *IncomingTopicMessageMock) Body() []byte {
	if mock.BodyFunc == nil {
		panic("IncomingTopicMessageMock.BodyFunc: method is nil but IncomingTopicMessage.Body was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBody.Lock()
	mock.calls.Body = append(mock.calls.Body, callInfo)
	mock.lockBody.Unlock()
	return mock.BodyFunc()
}

// BodyCalls gets all the calls that were made to Body.
// Check the length with:
//
//	len(mockedIncomingTopicMessage.BodyCalls())
func (mock *IncomingTopicMessageMock) BodyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBody.RLock()
	calls = mock.calls.Body
	mock.lockBody.RUnlock()
	return calls
}

// ContentType calls ContentTypeFunc.
func (mock *IncomingTopicMessageMock) ContentType() string {
	if mock.ContentTypeFunc == nil {
		panic("IncomingTopicMessageMock.ContentTypeFunc: method is nil but IncomingTopicMessage.ContentType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContentType.Lock()
	mock.calls.ContentType = append(mock.calls.ContentType, callInfo)
	mock.lockContentType.Unlock()
	return mock.ContentTypeFunc()
}

// ContentTypeCalls gets all the calls that were made to ContentType.
// Check the length with:
//
//	len(mockedIncomingTopicMessage.ContentTypeCalls())
func (mock *IncomingTopicMessageMock) ContentTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContentType.RLock()
	calls = mock.calls.ContentType
	mock.lockContentType.RUnlock()
	return calls
}

// TopicName calls TopicNameFunc.
func (mock *IncomingTopicMessageMock) TopicName() string {
	if mock.TopicNameFunc == nil {
		panic("IncomingTopicMessageMock.TopicNameFunc: method is nil but IncomingTopicMessage.TopicName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTopicName.Lock()
	mock.calls.TopicName = append(mock.calls.TopicName, callInfo)
	mock.lockTopicName.Unlock()
	return mock.TopicNameFunc()
}

// TopicNameCalls gets all the calls that were made to TopicName.
// Check the length with:
//
//	len(mockedIncomingTopicMessage.TopicNameCalls())
func (mock *IncomingTopicMessageMock) TopicNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTopicName.RLock()
	calls = mock.calls.TopicName
	mock.lockTopicName.RUnlock()
	return calls
}
